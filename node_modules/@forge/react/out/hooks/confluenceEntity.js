"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.confluenceEntity = exports.confAPIEndpoints = void 0;
const bridge_1 = require("@forge/bridge");
const apiRequestUtils_1 = require("./utils/apiRequestUtils");
const valueUtils_1 = require("./utils/valueUtils");
const types_1 = require("./types");
/**
 * given an entityType and a product context, returns functions that uses property data to
 * output URLs to use for property management via Confluence v2 REST API
 */
const confAPIEndpoints = ({ entityType, context }) => {
    let entityId, urlEntity;
    switch (entityType) {
        case 'Space':
            entityId = context.extension.space?.id;
            urlEntity = 'spaces';
            break;
        case 'Content':
            entityId = context.extension.content?.id;
            urlEntity = 'pages';
            break;
        default:
            throw new Error('Invalid entity type.');
    }
    if (!entityId) {
        throw new Error(`${entityType} properties not available for this app.`);
    }
    return {
        create: () => `/wiki/api/v2/${urlEntity}/${entityId}/properties`,
        fetch: (propertyKey) => `/wiki/api/v2/${urlEntity}/${entityId}/properties?key=${propertyKey}`,
        update: (propertyId) => `/wiki/api/v2/${urlEntity}/${entityId}/properties/${propertyId}`,
        delete: (propertyId) => `/wiki/api/v2/${urlEntity}/${entityId}/properties/${propertyId}`
    };
};
exports.confAPIEndpoints = confAPIEndpoints;
const confluenceEntity = ({ entityType, origPropertyKey, initValue }) => {
    const apiMethod = bridge_1.requestConfluence;
    const withConfluenceContext = (originalOperation) => {
        return (0, apiRequestUtils_1.withContext)({
            originalOperation,
            apiEndpoints: exports.confAPIEndpoints,
            entityType,
            origPropertyKey
        });
    };
    // fetches existing prop value from server. to be reused for GET, UPDATE, DELETE operations
    const fetchOriginal = async ({ endpointFactory, propertyKey }) => {
        const url = endpointFactory.fetch(propertyKey);
        const response = await (0, apiRequestUtils_1.makeRequest)({ url, apiMethod, method: 'GET' });
        (0, apiRequestUtils_1.assertSuccessfulResponse)({ entityType, propertyKey, operation: 'fetch', response });
        const existingData = await (0, apiRequestUtils_1.getJSONData)(response);
        return existingData.results[0];
    };
    // named `deleteProp` since `delete` is reserved word
    const deleteProp = async ({ endpointFactory, propertyKey }) => {
        // fetch original prop first to get its id
        const originalProp = await fetchOriginal({ endpointFactory, propertyKey });
        if (!originalProp) {
            throw new types_1.EntityPropertyRequestFailedError({
                entityType,
                propertyKey,
                operation: 'delete',
                status: 404
            });
        }
        const propertyId = originalProp.id;
        const url = endpointFactory.delete(propertyId);
        const response = await (0, apiRequestUtils_1.makeRequest)({ url, apiMethod, method: 'DELETE' });
        (0, apiRequestUtils_1.assertSuccessfulResponse)({ entityType, propertyKey, operation: 'delete', response });
    };
    const get = async ({ endpointFactory, propertyKey }) => {
        const existingProp = await fetchOriginal({ endpointFactory, propertyKey });
        if (existingProp) {
            return existingProp.value;
        }
        // if property doesn't exist, create it
        const resolvedInitVal = await (0, valueUtils_1.resolveValue)(initValue);
        const url = endpointFactory.create();
        const body = JSON.stringify({ key: propertyKey, value: resolvedInitVal });
        const response = await (0, apiRequestUtils_1.makeRequest)({ url, apiMethod, method: 'POST', body });
        (0, apiRequestUtils_1.assertSuccessfulResponse)({ entityType, propertyKey, operation: 'create', response });
        return (await (0, apiRequestUtils_1.getJSONData)(response)).value;
    };
    const update = async ({ endpointFactory, propertyKey }, valueUpdate) => {
        // fetch original prop first to update based on its value + version + id
        const originalProp = await fetchOriginal({ endpointFactory, propertyKey });
        if (!originalProp) {
            throw new types_1.EntityPropertyRequestFailedError({
                entityType,
                propertyKey,
                operation: 'update',
                status: 404
            });
        }
        const newValue = valueUpdate instanceof Function ? valueUpdate(originalProp.value) : valueUpdate;
        const propertyId = originalProp.id;
        const origVersion = originalProp?.version?.number;
        const url = endpointFactory.update(propertyId);
        const body = JSON.stringify({
            key: propertyKey,
            value: newValue,
            version: {
                number: origVersion + 1,
                message: `Update through UI Kit 2 use${entityType}Properties hook.`
            }
        });
        const response = await (0, apiRequestUtils_1.makeRequest)({ url, apiMethod, method: 'PUT', body });
        (0, apiRequestUtils_1.assertSuccessfulResponse)({ entityType, propertyKey, operation: 'update', response });
        return (await (0, apiRequestUtils_1.getJSONData)(response)).value;
    };
    return {
        get: withConfluenceContext(get),
        update: withConfluenceContext(update),
        delete: withConfluenceContext(deleteProp)
    };
};
exports.confluenceEntity = confluenceEntity;

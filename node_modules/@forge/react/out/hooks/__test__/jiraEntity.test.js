"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// defining mock functions above import so they are initialised before jest.mock runs
const mockRequestJira = jest.fn();
const mockGetContext = jest.fn(async () => mockPropertyHook_1.mockJiraContext);
const jiraEntity_1 = require("../jiraEntity");
const mockPropertyHook_1 = require("./mockPropertyHook");
jest.mock('@forge/bridge', () => ({
    requestJira: mockRequestJira,
    view: { getContext: mockGetContext }
}));
describe('issueAPIEndpoints string generation, given an entityType, productContext and required property data', () => {
    const issueEndpoints = (0, jiraEntity_1.issueAPIEndpoints)(mockPropertyHook_1.mockJiraContext);
    it('should generate the expected property create URL', () => {
        expect(issueEndpoints.create()).toEqual('/rest/api/2/issue/properties');
    });
    it('should generate the expected property get URL', () => {
        expect(issueEndpoints.fetch('MOCK_PROP_KEY')).toEqual('/rest/api/2/issue/MOCK_ISSUE_ID/properties/MOCK_PROP_KEY');
    });
    it('should generate the expected property update URL', () => {
        expect(issueEndpoints.update('MOCK_PROP_KEY')).toEqual('/rest/api/2/issue/MOCK_ISSUE_ID/properties/MOCK_PROP_KEY');
    });
    it('should generate the expected property delete URL', () => {
        expect(issueEndpoints.delete('MOCK_PROP_KEY')).toEqual('/rest/api/2/issue/MOCK_ISSUE_ID/properties/MOCK_PROP_KEY');
    });
    it('should throw an error if issueId not available', () => {
        const emptyContext = { localId: '', extension: {} };
        expect(() => (0, jiraEntity_1.issueAPIEndpoints)(emptyContext)).toThrow('Issue properties not available for this app.');
    });
});
describe('jiraIssuePropsManager', () => {
    const issueProps = (0, jiraEntity_1.jiraIssuePropsManager)({
        entityType: 'Issue',
        origPropertyKey: 'MOCK_PROP_KEY',
        initValue: mockPropertyHook_1.DEFAULT_PROP_VALUE
    });
    const issueEndpoints = (0, jiraEntity_1.issueAPIEndpoints)(mockPropertyHook_1.mockJiraContext);
    afterEach(() => jest.clearAllMocks());
    describe('when running its get() output function', () => {
        beforeAll(() => {
            mockRequestJira.mockResolvedValue(mockPropertyHook_1.mockJiraGetExistingRes);
        });
        it('should make a GET request with the right URL', async () => {
            const issueGetUrl = issueEndpoints.fetch('forge-MOCK_PROP_KEY');
            const issueGetBody = expect.objectContaining({ method: 'GET' });
            await issueProps.get();
            expect(mockRequestJira).toHaveBeenNthCalledWith(1, issueGetUrl, issueGetBody);
        });
        it('if the property exists, it should return its value', async () => {
            const output = await issueProps.get();
            expect(output).toEqual(mockPropertyHook_1.EXISTING_PROP_VALUE);
            expect(mockRequestJira).toHaveBeenCalledTimes(1); // stop making further requests
        });
        it('should throw an error if the GET request fails', async () => {
            mockRequestJira.mockResolvedValueOnce(mockPropertyHook_1.mockFailedRes);
            await expect(issueProps.get).rejects.toThrow(`The request to fetch the issue property (forge-MOCK_PROP_KEY) failed with status (400).`);
        });
        describe('if the property does not exist, it should create it', () => {
            beforeEach(() => {
                mockRequestJira.mockResolvedValueOnce(mockPropertyHook_1.mockJiraGetNonExistentRes).mockResolvedValueOnce(mockPropertyHook_1.mockJiraSuccessRes);
            });
            it('should make a POST request to the API with the right URL and body', async () => {
                const issuePostUrl = issueEndpoints.create();
                const issuePostBody = expect.objectContaining({
                    method: 'POST',
                    body: JSON.stringify({
                        entitiesIds: ['MOCK_ISSUE_ID'],
                        properties: { 'forge-MOCK_PROP_KEY': mockPropertyHook_1.DEFAULT_PROP_VALUE }
                    })
                });
                await issueProps.get();
                expect(mockRequestJira).toHaveBeenCalledTimes(2);
                expect(mockRequestJira).toHaveBeenNthCalledWith(2, issuePostUrl, issuePostBody);
            });
            it('should return the value of the created property (i.e. DEFAULT_PROP_VALUE value)', async () => {
                const output = await issueProps.get();
                expect(output).toEqual(mockPropertyHook_1.DEFAULT_PROP_VALUE);
            });
            it('should throw an error if the POST request fails', async () => {
                mockRequestJira.mockReset();
                mockRequestJira.mockResolvedValueOnce(mockPropertyHook_1.mockJiraGetNonExistentRes).mockResolvedValueOnce(mockPropertyHook_1.mockFailedRes);
                await expect(issueProps.get).rejects.toThrow(`The request to create the issue property (forge-MOCK_PROP_KEY) failed with status (400).`);
            });
        });
    });
    describe('when running its update() output function', () => {
        beforeEach(() => {
            mockRequestJira.mockResolvedValueOnce(mockPropertyHook_1.mockJiraGetExistingRes).mockResolvedValueOnce(mockPropertyHook_1.mockJiraSuccessRes);
        });
        describe('when updating with a concrete value', () => {
            it('should make a PUT request with the right url and body', async () => {
                const issuePutUrl = issueEndpoints.update('forge-MOCK_PROP_KEY');
                const issuePutBody = expect.objectContaining({
                    body: JSON.stringify(mockPropertyHook_1.UPDATED_PROP_VALUE)
                });
                await issueProps.update(mockPropertyHook_1.UPDATED_PROP_VALUE);
                expect(mockRequestJira).toHaveBeenCalledTimes(1);
                expect(mockRequestJira).toHaveBeenNthCalledWith(1, issuePutUrl, issuePutBody);
            });
            it('should return the value of the UPDATED_PROP_VALUE property when updating with concrete value', async () => {
                const valUpdate = await issueProps.update(mockPropertyHook_1.UPDATED_PROP_VALUE);
                expect(valUpdate).toEqual(mockPropertyHook_1.UPDATED_PROP_VALUE);
            });
        });
        describe('when updating with a setter function', () => {
            const updateCBFunc = (existingVal) => {
                return existingVal * mockPropertyHook_1.UPDATED_PROP_VALUE;
            };
            const expectedResult = mockPropertyHook_1.EXISTING_PROP_VALUE * mockPropertyHook_1.UPDATED_PROP_VALUE;
            it('should fetch the original property, then make a PUT request with the right url and body', async () => {
                const issueGetUrl = issueEndpoints.fetch('forge-MOCK_PROP_KEY');
                const issueGetBody = expect.objectContaining({ method: 'GET' });
                const issuePutUrl = issueEndpoints.update('forge-MOCK_PROP_KEY');
                const issuePutBody = expect.objectContaining({
                    body: JSON.stringify(updateCBFunc(mockPropertyHook_1.EXISTING_PROP_VALUE))
                });
                await issueProps.update(updateCBFunc);
                expect(mockRequestJira).toHaveBeenCalledTimes(2);
                expect(mockRequestJira).toHaveBeenNthCalledWith(1, issueGetUrl, issueGetBody);
                expect(mockRequestJira).toHaveBeenNthCalledWith(2, issuePutUrl, issuePutBody);
            });
            it('should return the value of the UPDATED_PROP_VALUE property when updating with setter function', async () => {
                const funcUpdate = await issueProps.update(updateCBFunc);
                expect(funcUpdate).toEqual(expectedResult);
            });
        });
        it('should throw an error if the PUT request fails', async () => {
            mockRequestJira.mockReset();
            mockRequestJira.mockResolvedValue(mockPropertyHook_1.mockFailedRes);
            await expect(() => issueProps.update(mockPropertyHook_1.UPDATED_PROP_VALUE)).rejects.toThrow(`The request to update the issue property (forge-MOCK_PROP_KEY) failed with status (400).`);
        });
    });
    describe('when running its delete() output function', () => {
        beforeEach(() => {
            mockRequestJira.mockResolvedValueOnce(mockPropertyHook_1.mockJiraGetExistingRes).mockResolvedValueOnce(mockPropertyHook_1.mockJiraSuccessRes);
        });
        it('should make a DELETE request to the API with the right url', async () => {
            const issueDeleteUrl = issueEndpoints.delete('forge-MOCK_PROP_KEY');
            const issueDeleteBody = expect.objectContaining({ method: 'DELETE' });
            await issueProps.delete();
            expect(mockRequestJira).toHaveBeenCalledTimes(1);
            expect(mockRequestJira).toHaveBeenNthCalledWith(1, issueDeleteUrl, issueDeleteBody);
        });
        it('should throw an error if the DELETE request fails', async () => {
            mockRequestJira.mockReset();
            mockRequestJira.mockResolvedValueOnce(mockPropertyHook_1.mockFailedRes);
            await expect(issueProps.delete).rejects.toThrow(`The request to delete the issue property (forge-MOCK_PROP_KEY) failed with status (400).`);
        });
    });
});

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
// defining mock function above import so it is initialised before jest.mock runs
const mockGetContext = jest.fn(async () => null);
const useProductContext_1 = require("../useProductContext");
const react_1 = tslib_1.__importStar(require("react"));
const testUtils_1 = require("../../__test__/testUtils");
const reconcilerTestRenderer_1 = tslib_1.__importDefault(require("../../__test__/reconcilerTestRenderer"));
jest.mock('@forge/bridge', () => ({
    view: {
        getContext: mockGetContext
    }
}));
const MOCK_CONTEXT = {
    accountId: 'client-accountId',
    cloudId: 'DUMMY-cloudId',
    extension: { contentId: 'DUMMY-contentId' },
    license: undefined,
    localId: 'DUMMY-localId',
    locale: 'DUMMY-locale',
    moduleKey: 'DUMMY-moduleKey',
    siteUrl: 'DUMMY-siteUrl',
    timezone: 'DUMMY-timezone'
};
const prodContListener = jest.fn();
// react app fragment to be load useProductContext hook
const renderTest = async () => {
    const Test = () => {
        const prodCont = (0, useProductContext_1.useProductContext)();
        (0, react_1.useEffect)(() => prodContListener(prodCont), [prodCont]);
        return (0, jsx_runtime_1.jsx)(react_1.default.Fragment, {});
    };
    await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(Test, {}));
};
describe('useProductContext', () => {
    const LOAD_TIME = 500;
    beforeAll(() => (0, testUtils_1.setupBridge)());
    afterEach(() => jest.clearAllMocks());
    it("automatically fetches data via bridge's view.getContext()", async () => {
        await renderTest();
        expect(mockGetContext).toHaveBeenCalled();
    });
    it('corrently renders an expected ProductContext that is available upon load', async () => {
        mockGetContext.mockResolvedValue(MOCK_CONTEXT);
        await renderTest();
        expect(prodContListener.mock.calls[1][0]).toEqual(MOCK_CONTEXT);
    });
    it('corrently renders an expected ProductContext that takes time to load', async () => {
        mockGetContext.mockImplementation(async () => {
            await new Promise((res) => setTimeout(res, LOAD_TIME));
            return MOCK_CONTEXT;
        });
        await renderTest();
        expect(prodContListener).not.toHaveBeenNthCalledWith(2, expect.anything());
        await new Promise((res) => setTimeout(res, LOAD_TIME * 2)); // wait for data to load
        expect(prodContListener.mock.calls[1][0]).toEqual(MOCK_CONTEXT);
    }, LOAD_TIME * 3);
});

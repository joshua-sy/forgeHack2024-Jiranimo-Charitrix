"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = tslib_1.__importStar(require("react"));
const testUtils_1 = require("../../__test__/testUtils");
const reconcilerTestRenderer_1 = tslib_1.__importDefault(require("../../__test__/reconcilerTestRenderer"));
const mockPropertyHook_1 = require("./mockPropertyHook");
const useEntityProperty_1 = require("../useEntityProperty");
const mockRequest = jest.fn();
const mockEntity = () => ({
    get: async () => {
        mockRequest('get');
        return mockPropertyHook_1.EXISTING_PROP_VALUE;
    },
    update: async () => {
        const response = await mockRequest('update');
        if (!response.ok) {
            throw new Error();
        }
        return mockPropertyHook_1.UPDATED_PROP_VALUE;
    },
    delete: async () => {
        mockRequest('delete');
    }
});
const useMockEntityProperty = (defaultRetryCount = 2) => {
    const entityManager = (0, react_1.useMemo)(mockEntity, []);
    return (0, useEntityProperty_1.useEntityProperty)({ entityManager, defaultRetryCount });
};
const propListener = jest.fn();
var renderActions;
(function (renderActions) {
    renderActions[renderActions["noAction"] = 0] = "noAction";
    renderActions[renderActions["toUpdate"] = 1] = "toUpdate";
    renderActions[renderActions["toDelete"] = 2] = "toDelete";
})(renderActions || (renderActions = {}));
const renderTest = async (action = renderActions.noAction, retryCount) => {
    const Test = () => {
        const [prop, setProp, delProp] = useMockEntityProperty(retryCount);
        (0, react_1.useEffect)(() => propListener(prop), [prop]);
        (0, react_1.useEffect)(() => {
            if (action === renderActions.toUpdate) {
                setProp(mockPropertyHook_1.UPDATED_PROP_VALUE, retryCount).catch((err) => {
                    console.error(err); // eslint-disable-line no-console
                });
            }
            if (action === renderActions.toDelete) {
                void delProp();
            }
        }, []);
        return (0, jsx_runtime_1.jsx)(react_1.default.Fragment, {});
    };
    await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(Test, {}));
};
describe('useEntityProperty', () => {
    beforeAll(testUtils_1.setupBridge);
    beforeEach(() => {
        mockRequest.mockResolvedValue(mockPropertyHook_1.mockConfGetExistingRes);
    });
    afterEach(() => {
        jest.clearAllMocks();
    });
    describe('initial returned prop value', () => {
        it("is acquired from the given entityManager's get() function", async () => {
            await renderTest();
            expect(mockRequest).toHaveBeenNthCalledWith(1, 'get');
        });
        it('is statefully and correctly rendered', async () => {
            await renderTest();
            expect(propListener).toHaveBeenNthCalledWith(1, undefined);
            expect(propListener).toHaveBeenNthCalledWith(2, mockPropertyHook_1.EXISTING_PROP_VALUE);
        });
    });
    describe('returned value-setting function', () => {
        it("calls the given entityManager's update() function", async () => {
            await renderTest(renderActions.toUpdate);
            expect(mockRequest).toHaveBeenNthCalledWith(2, 'update');
        });
        it('updates the returned prop value statefully and correctly', async () => {
            await renderTest(renderActions.toUpdate);
            expect(propListener).toHaveBeenNthCalledWith(3, mockPropertyHook_1.UPDATED_PROP_VALUE);
        });
        it('makes 2 retries (by default) when initial attempt fails', async () => {
            mockRequest.mockResolvedValue(() => mockPropertyHook_1.mockFailedRes);
            await renderTest(renderActions.toUpdate);
            expect(mockRequest).toHaveBeenNthCalledWith(2, 'update'); // initial attempt
            expect(mockRequest).toHaveBeenNthCalledWith(3, 'update');
            expect(mockRequest).toHaveBeenNthCalledWith(4, 'update');
            expect(mockRequest).not.toHaveBeenNthCalledWith(5, 'update');
        });
        it('stops retrying when a previous retry succeeds', async () => {
            mockRequest.mockResolvedValueOnce(() => mockPropertyHook_1.mockFailedRes).mockResolvedValueOnce(() => mockPropertyHook_1.mockConfUpdateValueRes);
            await renderTest(renderActions.toUpdate);
            expect(mockRequest).toHaveBeenNthCalledWith(2, 'update'); // initial attempt
            expect(mockRequest).toHaveBeenNthCalledWith(3, 'update');
            expect(mockRequest).not.toHaveBeenNthCalledWith(4, 'update');
        });
        it('makes custom number of retries (if given) when initial attempts fails', async () => {
            const retryCount = 5;
            mockRequest.mockResolvedValue(() => mockPropertyHook_1.mockFailedRes);
            await renderTest(renderActions.toUpdate, retryCount);
            for (let i = 2; i <= retryCount + 2; i++) {
                expect(mockRequest).toHaveBeenNthCalledWith(i, 'update');
            }
            expect(mockRequest).not.toHaveBeenNthCalledWith(retryCount + 3, 'update');
        });
    });
    describe('returned property-deleting function', () => {
        it("calls the given entityManager's delete() function", async () => {
            await renderTest(renderActions.toDelete);
            expect(mockRequest).toHaveBeenNthCalledWith(2, 'delete');
        });
        it('updates the outputted prop value statefully to undefined', async () => {
            await renderTest(renderActions.toDelete);
            expect(propListener).toHaveBeenNthCalledWith(3, undefined);
        });
    });
});

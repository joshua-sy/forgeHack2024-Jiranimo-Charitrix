"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jiraIssuePropsManager = exports.issueAPIEndpoints = void 0;
const bridge_1 = require("@forge/bridge");
const apiRequestUtils_1 = require("./utils/apiRequestUtils");
const valueUtils_1 = require("./utils/valueUtils");
const types_1 = require("./types");
/**
 * given a context, returns functions that uses property data to
 * output URLs to use for issue property management via Jira v2 REST API
 */
const issueAPIEndpoints = (context) => {
    const issueId = context.extension.issue?.id;
    if (!issueId)
        throw new Error('Issue properties not available for this app.');
    return {
        create: () => `/rest/api/2/issue/properties`,
        fetch: (propertyKey) => `/rest/api/2/issue/${issueId}/properties/${propertyKey}`,
        update: (propertyKey) => `/rest/api/2/issue/${issueId}/properties/${propertyKey}`,
        delete: (propertyKey) => `/rest/api/2/issue/${issueId}/properties/${propertyKey}`
    };
};
exports.issueAPIEndpoints = issueAPIEndpoints;
const jiraIssuePropsManager = ({ origPropertyKey, initValue }) => {
    const entityType = 'Issue';
    const apiMethod = bridge_1.requestJira;
    const withIssueContext = (originalOperation) => {
        return (0, apiRequestUtils_1.withContext)({
            originalOperation,
            apiEndpoints: exports.issueAPIEndpoints,
            entityType: 'Issue',
            origPropertyKey
        });
    };
    // fetches existing prop value from server. to be reused for GET, UPDATE, DELETE operations
    const fetchOriginal = async ({ endpointFactory, propertyKey }) => {
        const url = endpointFactory.fetch(propertyKey);
        const response = await (0, apiRequestUtils_1.makeRequest)({ url, apiMethod, method: 'GET' });
        try {
            (0, apiRequestUtils_1.assertSuccessfulResponse)({ entityType, propertyKey, operation: 'fetch', response });
        }
        catch (err) {
            if (response.status === 404) {
                return null;
            }
            else {
                throw err;
            }
        }
        const existingData = await (0, apiRequestUtils_1.getJSONData)(response);
        return existingData;
    };
    // named `deleteProp` since `delete` is reserved word
    const deleteProp = async ({ endpointFactory, propertyKey }) => {
        const url = endpointFactory.delete(propertyKey);
        const response = await (0, apiRequestUtils_1.makeRequest)({ url, apiMethod, method: 'DELETE' });
        (0, apiRequestUtils_1.assertSuccessfulResponse)({ entityType, propertyKey, operation: 'delete', response });
    };
    const get = async ({ endpointFactory, propertyKey, context }) => {
        const existingProp = await fetchOriginal({ endpointFactory, propertyKey, context });
        if (existingProp) {
            return existingProp.value;
        }
        // if property doesn't exist, create it
        const resolvedInitVal = await (0, valueUtils_1.resolveValue)(initValue);
        const url = endpointFactory.create();
        const entityId = context.extension.issue?.id;
        const bodyData = {
            entitiesIds: [entityId],
            properties: {
                [propertyKey]: resolvedInitVal
            }
        };
        const response = await (0, apiRequestUtils_1.makeRequest)({
            url,
            apiMethod,
            method: 'POST',
            body: JSON.stringify(bodyData)
        });
        (0, apiRequestUtils_1.assertSuccessfulResponse)({ entityType, propertyKey, operation: 'create', response });
        return resolvedInitVal;
    };
    const update = async ({ endpointFactory, propertyKey, context }, valueUpdate) => {
        const newValueOrRunUpdaterOnOriginal = async (valueUpdate) => {
            // concrete value update, does not require fetching original value
            if (!(valueUpdate instanceof Function)) {
                return valueUpdate;
            }
            // value update via function, fetch original prop first to update based on its value
            const originalProp = await fetchOriginal({ endpointFactory, propertyKey, context });
            if (!originalProp) {
                throw new types_1.EntityPropertyRequestFailedError({
                    entityType,
                    propertyKey,
                    operation: 'update',
                    status: 404
                });
            }
            return valueUpdate(originalProp.value);
        };
        const newValue = await newValueOrRunUpdaterOnOriginal(valueUpdate);
        const url = endpointFactory.update(propertyKey);
        const body = JSON.stringify(newValue);
        const response = await (0, apiRequestUtils_1.makeRequest)({ url, apiMethod, method: 'PUT', body });
        (0, apiRequestUtils_1.assertSuccessfulResponse)({ entityType, propertyKey, operation: 'update', response });
        return newValue;
    };
    return {
        get: withIssueContext(get),
        update: withIssueContext(update),
        delete: withIssueContext(deleteProp)
    };
};
exports.jiraIssuePropsManager = jiraIssuePropsManager;

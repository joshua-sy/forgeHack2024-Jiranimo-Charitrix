import { FieldValues, UseFormProps, FieldPath, RegisterOptions, UseFormRegisterReturn } from 'react-hook-form';
declare type ForgeOnChangeHandler = (event: {
    target: any;
    type?: string;
} | any) => void;
declare type ForgeFormRegister = Pick<UseFormRegisterReturn, 'name'> & {
    onChange: ForgeOnChangeHandler;
    onBlur: () => void;
    id: string;
    defaultValue?: any;
    defaultChecked?: boolean;
    isDisabled?: boolean;
    isInvalid?: boolean;
    'aria-invalid'?: any;
};
export declare function useForm<TFieldValues extends FieldValues = FieldValues>(props?: Pick<UseFormProps<TFieldValues>, 'defaultValues'>): {
    getFieldId: (fieldName: string) => string;
    register: (fieldName: FieldPath<TFieldValues>, options?: Pick<RegisterOptions<TFieldValues, FieldPath<TFieldValues>>, 'disabled' | 'required' | 'maxLength' | 'minLength' | 'max' | 'min' | 'pattern' | 'validate'>) => ForgeFormRegister;
    formState: {
        errors: import("react-hook-form").FieldErrors<TFieldValues>;
        isSubmitted: boolean;
        isSubmitSuccessful: boolean;
        isSubmitting: boolean;
        submitCount: number;
        isValid: boolean;
        dirtyFields: Partial<Readonly<import("react-hook-form").DeepMap<import("react-hook-form").DeepPartial<TFieldValues>, boolean>>>;
        touchedFields: Partial<Readonly<import("react-hook-form").DeepMap<import("react-hook-form").DeepPartial<TFieldValues>, boolean>>>;
    };
    handleSubmit: import("react-hook-form").UseFormHandleSubmit<TFieldValues, TFieldValues>;
    getValues: import("react-hook-form").UseFormGetValues<TFieldValues>;
    trigger: import("react-hook-form").UseFormTrigger<TFieldValues>;
    clearErrors: import("react-hook-form").UseFormClearErrors<TFieldValues>;
};
export {};
//# sourceMappingURL=useForm.d.ts.map
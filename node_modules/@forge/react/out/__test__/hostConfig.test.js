"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
let keyCount = 0;
jest.mock('uuid', () => ({
    ...jest.requireActual('uuid'),
    v4: () => `${keyCount++}`
}));
const reconciler_1 = require("../reconciler");
const testUtils_1 = require("./testUtils");
const emptyForgeDoc = (0, reconciler_1.createElement)({ type: 'root', props: {} });
describe('hostConfig used functions', () => {
    let bridgeCalls = [];
    beforeAll(async () => {
        bridgeCalls = (0, testUtils_1.setupBridge)();
        keyCount = 0;
    });
    it('resetAfterCommit should call bridge', () => {
        const testDoc = (0, reconciler_1.createElement)({ type: 'root', props: {} });
        reconciler_1.hostConfig.resetAfterCommit(testDoc);
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(forgeDoc).toMatchSnapshot();
    });
    it('createInstance returns empty ForgeDoc', () => {
        const testProps = {
            test: true
        };
        const instance = reconciler_1.hostConfig.createInstance('test', testProps, emptyForgeDoc, null, null);
        expect(instance).toMatchSnapshot();
    });
    it('createTextInstance returns ForgeDoc with UUID', () => {
        const testDoc = (0, reconciler_1.createElement)({ type: 'root', props: {} });
        const textInstance = reconciler_1.hostConfig.createTextInstance('test', testDoc, null, null);
        expect(textInstance).toMatchSnapshot();
    });
    it('appendInitialChild adds child to empty children array', () => {
        const parent = (0, reconciler_1.createElement)({ type: 'parent', props: {} });
        const child = (0, reconciler_1.createElement)({ type: 'child', props: {} });
        expect(parent).toHaveProperty('children', []);
        reconciler_1.hostConfig.appendInitialChild(parent, child);
        expect(parent).toHaveProperty('children', [child]);
    });
    it('appendChild does not append same child twice', () => {
        expect(reconciler_1.hostConfig).toHaveProperty('appendChild');
        if (reconciler_1.hostConfig.appendChild !== undefined) {
            const parent = (0, reconciler_1.createElement)({ type: 'parent', props: {} });
            const child = (0, reconciler_1.createElement)({ type: 'child', props: {} });
            expect(parent).toHaveProperty('children', []);
            reconciler_1.hostConfig.appendChild(parent, child);
            expect(parent).toHaveProperty('children', [child]);
            reconciler_1.hostConfig.appendChild(parent, child);
            expect(parent).toHaveProperty('children', [child]); // Still just one child!
        }
    });
    it('appendChildToContainer', () => {
        expect(reconciler_1.hostConfig).toHaveProperty('appendChildToContainer');
        if (reconciler_1.hostConfig.appendChildToContainer !== undefined) {
            const parent = (0, reconciler_1.createElement)({ type: 'parent', props: {} });
            const child = (0, reconciler_1.createElement)({ type: 'child', props: {} });
            expect(parent).toHaveProperty('children', []);
            reconciler_1.hostConfig.appendChildToContainer(parent, child);
            expect(parent).toHaveProperty('children', [child]);
        }
    });
    it('finalizeInitialChildren returns false', () => {
        expect(reconciler_1.hostConfig.finalizeInitialChildren(emptyForgeDoc, 'test', {}, emptyForgeDoc, null)).toBe(false);
    });
    it('prepareUpdate should set new props as props on instance', () => {
        const instance = (0, reconciler_1.createElement)({ type: 'test', props: { oldProps: true } });
        const newProps = {
            updated: true
        };
        expect(reconciler_1.hostConfig.prepareUpdate(instance, 'test', {}, newProps, emptyForgeDoc, null)).toBe(newProps);
        expect(instance).not.toHaveProperty('oldProps');
        expect(instance).toHaveProperty('props', newProps);
    });
    it('shouldSetTextContent returns false', () => {
        expect(reconciler_1.hostConfig.shouldSetTextContent('test', {})).toBe(false);
    });
    it('insertBefore reorders children', () => {
        expect(reconciler_1.hostConfig).toHaveProperty('insertBefore');
        if (reconciler_1.hostConfig.insertBefore !== undefined) {
            const parent = (0, reconciler_1.createElement)({ type: 'parent', props: {} });
            const child1 = (0, reconciler_1.createElement)({ type: 'child1', props: {} });
            const child2 = (0, reconciler_1.createElement)({ type: 'child2', props: {} });
            reconciler_1.hostConfig.appendInitialChild(parent, child1);
            expect(parent).toHaveProperty('children', [child1]);
            reconciler_1.hostConfig.insertBefore(parent, child2, child1);
            expect(parent).toHaveProperty('children', [child2, child1]);
        }
    });
    it('insertInContainerBefore reorders children when child being inserted exists', () => {
        expect(reconciler_1.hostConfig).toHaveProperty('insertInContainerBefore');
        if (reconciler_1.hostConfig.insertInContainerBefore !== undefined) {
            const parent = (0, reconciler_1.createElement)({ type: 'parent', props: {} });
            const child1 = (0, reconciler_1.createElement)({ type: 'child1', props: {} });
            const child2 = (0, reconciler_1.createElement)({ type: 'child2', props: {} });
            reconciler_1.hostConfig.appendInitialChild(parent, child1);
            reconciler_1.hostConfig.appendInitialChild(parent, child2);
            expect(parent).toHaveProperty('children', [child1, child2]);
            reconciler_1.hostConfig.insertInContainerBefore(parent, child2, child1);
            expect(parent).toHaveProperty('children', [child2, child1]);
        }
    });
    it('removeChild removes child', () => {
        expect(reconciler_1.hostConfig).toHaveProperty('removeChild');
        if (reconciler_1.hostConfig.removeChild !== undefined) {
            const parent = (0, reconciler_1.createElement)({ type: 'parent', props: {} });
            const child = (0, reconciler_1.createElement)({ type: 'child', props: {} });
            expect(parent).toHaveProperty('children', []);
            reconciler_1.hostConfig.appendInitialChild(parent, child);
            expect(parent).toHaveProperty('children', [child]);
            reconciler_1.hostConfig.removeChild(parent, child);
            expect(parent).toHaveProperty('children', []);
        }
    });
    it('removeChildFromContainer removes child', () => {
        expect(reconciler_1.hostConfig).toHaveProperty('removeChildFromContainer');
        if (reconciler_1.hostConfig.removeChildFromContainer !== undefined) {
            const parent = (0, reconciler_1.createElement)({ type: 'parent', props: {} });
            const child = (0, reconciler_1.createElement)({ type: 'child', props: {} });
            expect(parent).toHaveProperty('children', []);
            reconciler_1.hostConfig.appendInitialChild(parent, child);
            expect(parent).toHaveProperty('children', [child]);
            reconciler_1.hostConfig.removeChildFromContainer(parent, child);
            expect(parent).toHaveProperty('children', []);
        }
    });
    it('commitTextUpdate should update instance props', () => {
        expect(reconciler_1.hostConfig).toHaveProperty('commitTextUpdate');
        if (reconciler_1.hostConfig.commitTextUpdate !== undefined) {
            const testDoc = (0, reconciler_1.createElement)({ type: 'root', props: {} });
            const textInstance = reconciler_1.hostConfig.createTextInstance('test', testDoc, null, null);
            reconciler_1.hostConfig.commitTextUpdate(textInstance, '', 'updated');
            expect(textInstance).toEqual(expect.objectContaining({
                type: 'String',
                children: [],
                props: {
                    text: 'updated'
                },
                key: expect.any(String)
            }));
        }
    });
});
// The reason for including the following tests is to ensure that any changes to the
// HostConfig are verified both in the source and in the tests. The need to check that
// some of the functions are even defined indicates that we don't need to declare
// all the functions in the reconciler, but keeping them with the tets ensures we do the
// appropriate due diligence on any changes. It also ensures we have good code coverage!
describe('hostConfig unused functions', () => {
    it('should return empty object from getRootHostContext', () => {
        expect(reconciler_1.hostConfig.getRootHostContext(emptyForgeDoc)).toEqual({});
    });
    it('should return null from getChildHostContext', () => {
        expect(reconciler_1.hostConfig.getChildHostContext(null, 'test', emptyForgeDoc)).toBeNull();
    });
    it('should return supplied value to getPublicInstance', () => {
        expect(reconciler_1.hostConfig.getPublicInstance(emptyForgeDoc)).toBe(emptyForgeDoc);
    });
    it('should return null from prepareForCommit', () => {
        expect(reconciler_1.hostConfig.prepareForCommit(emptyForgeDoc)).toBeNull();
    });
    it('should return undefined from preparePortalMount', () => {
        expect(reconciler_1.hostConfig.preparePortalMount(emptyForgeDoc)).toBeUndefined();
    });
    it('should return undefined from resetTextContent', () => {
        if (reconciler_1.hostConfig.resetTextContent !== undefined) {
            expect(reconciler_1.hostConfig.resetTextContent(emptyForgeDoc)).toBeUndefined();
        }
    });
    it('should return undefined from commitMount', () => {
        if (reconciler_1.hostConfig.commitMount !== undefined) {
            expect(reconciler_1.hostConfig.commitMount(emptyForgeDoc, 'test', {}, null)).toBeUndefined();
        }
    });
    it('should return undefined from commitUpdate', () => {
        if (reconciler_1.hostConfig.commitUpdate !== undefined) {
            expect(reconciler_1.hostConfig.commitUpdate(emptyForgeDoc, {}, 'test', {}, {}, null)).toBeUndefined();
        }
    });
    it('should return undefined from hideInstance', () => {
        if (reconciler_1.hostConfig.hideInstance !== undefined) {
            expect(reconciler_1.hostConfig.hideInstance(emptyForgeDoc)).toBeUndefined();
        }
    });
    it('should return undefined from unhideTextInstance', () => {
        if (reconciler_1.hostConfig.unhideTextInstance !== undefined) {
            expect(reconciler_1.hostConfig.unhideTextInstance(emptyForgeDoc, 'Test')).toBeUndefined();
        }
    });
    it('should return undefined from clearContainer', () => {
        if (reconciler_1.hostConfig.clearContainer !== undefined) {
            expect(reconciler_1.hostConfig.clearContainer(emptyForgeDoc)).toBeUndefined();
        }
    });
    it('should return undefined from detachDeletedInstance', () => {
        expect(reconciler_1.hostConfig.detachDeletedInstance(emptyForgeDoc)).toBeUndefined();
    });
    it('should return undefined from getCurrentEventPriority', () => {
        expect(reconciler_1.hostConfig.getCurrentEventPriority()).toBe(16);
    });
    it('should return null from getInstanceFromNode', () => {
        expect(reconciler_1.hostConfig.getInstanceFromNode(null)).toBeNull();
    });
    it('should return undefined from beforeActiveInstanceBlur', () => {
        expect(reconciler_1.hostConfig.beforeActiveInstanceBlur()).toBeUndefined();
    });
    it('should return undefined from afterActiveInstanceBlur', () => {
        expect(reconciler_1.hostConfig.afterActiveInstanceBlur()).toBeUndefined();
    });
    it('should return undefined from prepareScopeUpdate', () => {
        expect(reconciler_1.hostConfig.prepareScopeUpdate(null, null)).toBeUndefined();
    });
    it('should return null from getInstanceFromScope', () => {
        expect(reconciler_1.hostConfig.getInstanceFromScope(null)).toBeNull();
    });
});

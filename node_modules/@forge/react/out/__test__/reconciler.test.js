"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
let keyCount = 0;
jest.mock('uuid', () => ({
    ...jest.requireActual('uuid'),
    v4: () => `${keyCount++}`
}));
const resetKeyCount = () => {
    keyCount = 0;
};
const react_1 = tslib_1.__importStar(require("react"));
const reconcilerTestRenderer_1 = tslib_1.__importDefault(require("./reconcilerTestRenderer"));
const components_1 = require("../components");
const get_1 = tslib_1.__importDefault(require("lodash/get"));
const testUtils_1 = require("./testUtils");
describe('Reconcilation', () => {
    resetKeyCount();
    let bridgeCalls = [];
    const TEXT = 0;
    const BUTTON = 1;
    const STATIC_TEXT = 2;
    const STRING = 0;
    beforeAll(async () => {
        bridgeCalls = (0, testUtils_1.setupBridge)();
        const Test = () => {
            const [bool, setBool] = (0, react_1.useState)(false);
            return ((0, jsx_runtime_1.jsxs)(react_1.default.Fragment, { children: [(0, jsx_runtime_1.jsx)(components_1.Text, { children: !bool ? 'Loading...' : 'Now loaded...' }), (0, jsx_runtime_1.jsx)(components_1.Button, { onClick: () => setBool(true), children: "Click" }), (0, jsx_runtime_1.jsx)(components_1.Lozenge, { appearance: "inprogress", children: "Test" })] }));
        };
        resetKeyCount();
        await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(Test, {}));
    });
    it('forgeDoc is created on initial render', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(forgeDoc).toHaveProperty(`children[${TEXT}].type`, 'Text'); // First child is text
        expect(forgeDoc).toHaveProperty(`children[${BUTTON}].type`, 'Button'); // Second child is button
        expect(forgeDoc).toHaveProperty(`children[${STATIC_TEXT}].type`, 'Lozenge');
        expect(forgeDoc).toMatchSnapshot();
    });
    it('forgeDoc is updated on state update', () => {
        let forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        // Get the click handler for the 1st button
        const onClick = (0, get_1.default)(forgeDoc, `children[${BUTTON}].props.onClick`);
        expect(onClick).not.toBeUndefined();
        onClick();
        forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(forgeDoc).toHaveProperty(`children[${TEXT}].children[${STRING}].type`, 'String');
        expect(forgeDoc).toHaveProperty(`children[${TEXT}].children[${STRING}].props.text`, 'Now loaded...');
        expect(forgeDoc).toMatchSnapshot();
    });
});
describe('deep tree reconciliation', () => {
    let bridgeCalls = [];
    beforeAll(async () => {
        bridgeCalls = (0, testUtils_1.setupBridge)();
        const Test = () => {
            const [count, setCount] = (0, react_1.useState)(0);
            function incrementCount() {
                setCount(count + 1);
            }
            return ((0, jsx_runtime_1.jsx)(react_1.default.Fragment, { children: (0, jsx_runtime_1.jsxs)(components_1.Inline, { children: [(0, jsx_runtime_1.jsx)(components_1.Stack, { children: (0, jsx_runtime_1.jsx)(components_1.Text, { children: count }) }), (0, jsx_runtime_1.jsxs)(components_1.Stack, { children: [(0, jsx_runtime_1.jsx)(components_1.Text, { children: "Should not update" }), (0, jsx_runtime_1.jsx)(components_1.Button, { onClick: incrementCount, children: "Click" })] })] }) }));
        };
        resetKeyCount();
        await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(Test, {}));
    });
    it('should match the initially rendered ForgeDoc snaphot', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(forgeDoc).toMatchSnapshot();
    });
    it('should match snapshot after triggering update', () => {
        let forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(forgeDoc).not.toBeNull();
        const button = (0, testUtils_1.findElementInForgeDoc)(forgeDoc, '8');
        expect(button).not.toBeUndefined();
        expect(button?.props?.onClick).not.toBeUndefined();
        button?.props?.onClick();
        forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(forgeDoc).toMatchSnapshot();
    });
});
describe('macro config', () => {
    it('should create forgeDoc tree for macro config', async () => {
        const bridgeCalls = (0, testUtils_1.setupBridge)();
        const App = () => {
            return ((0, jsx_runtime_1.jsx)(react_1.default.Fragment, { children: (0, jsx_runtime_1.jsx)(components_1.Text, { children: "Hello World" }) }));
        };
        const Config = () => {
            return (0, jsx_runtime_1.jsx)(components_1.Textfield, { name: "age" });
        };
        await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(App, {}));
        await reconcilerTestRenderer_1.default.addConfig((0, jsx_runtime_1.jsx)(Config, {}));
        const configForgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(configForgeDoc?.type).toEqual('MacroConfig');
        expect(configForgeDoc?.children[0].type).toEqual('Textfield');
    });
});
describe('id props', () => {
    let bridgeCalls = [];
    beforeAll(async () => {
        bridgeCalls = (0, testUtils_1.setupBridge)();
        const Test = () => {
            return ((0, jsx_runtime_1.jsxs)(react_1.default.Fragment, { children: [(0, jsx_runtime_1.jsx)(components_1.Label, { labelFor: "username", children: "username" }), (0, jsx_runtime_1.jsx)(components_1.Textfield, { id: "username", placeholder: "name" }), (0, jsx_runtime_1.jsx)(components_1.DatePicker, { id: "datepicker", placeholder: "date" })] }));
        };
        await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(Test, {}));
    });
    it('should contain a prefix', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(forgeDoc).toHaveProperty('children[0].props.labelFor', 'forge-app-0-username');
        expect(forgeDoc).toHaveProperty('children[1].props.id', 'forge-app-0-username');
        expect(forgeDoc).toHaveProperty('children[2].props.id', 'forge-app-0-datepicker');
    });
    it('should still contain other props', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(forgeDoc).toHaveProperty('children[1].props.placeholder', 'name');
        expect(forgeDoc).toHaveProperty('children[2].props.placeholder', 'date');
    });
});
describe('function props __id__ attributes', () => {
    let bridgeCalls = [];
    beforeAll(async () => {
        bridgeCalls = (0, testUtils_1.setupBridge)();
        const Test = () => {
            const [count, setCount] = (0, react_1.useState)(0);
            function incrementCount() {
                setCount(count + 1);
            }
            return ((0, jsx_runtime_1.jsx)(react_1.default.Fragment, { children: (0, jsx_runtime_1.jsxs)(components_1.Inline, { children: [(0, jsx_runtime_1.jsx)(components_1.Stack, { children: (0, jsx_runtime_1.jsx)(components_1.Text, { children: count }) }), (0, jsx_runtime_1.jsxs)(components_1.Stack, { children: [(0, jsx_runtime_1.jsx)(components_1.Button, { appearance: "danger", onClick: incrementCount, children: "Click" }), (0, jsx_runtime_1.jsx)(components_1.Stack, { children: (0, jsx_runtime_1.jsx)(components_1.Button, { autoFocus: true, onClick: () => setCount(0), children: "Reset" }) })] })] }) }));
        };
        resetKeyCount();
        await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(Test, {}));
    });
    it('should contain __id__ attribute for all function props', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect((0, testUtils_1.findElementInForgeDoc)(forgeDoc, '6')).toHaveProperty('props.onClick.__id__', '5');
        expect((0, testUtils_1.findElementInForgeDoc)(forgeDoc, '9')).toHaveProperty('props.onClick.__id__', '8');
    });
    it('should not contain __id__ attribute for non function props', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect((0, testUtils_1.findElementInForgeDoc)(forgeDoc, '6')?.props?.appearance).toBe('danger');
        expect((0, testUtils_1.findElementInForgeDoc)(forgeDoc, '6')?.props?.appearance?.__id__).toBeUndefined();
        expect((0, testUtils_1.findElementInForgeDoc)(forgeDoc, '9')?.props?.autoFocus).toBe(true);
        expect((0, testUtils_1.findElementInForgeDoc)(forgeDoc, '9')?.props?.autoFocus?.__id__).toBeUndefined();
    });
});

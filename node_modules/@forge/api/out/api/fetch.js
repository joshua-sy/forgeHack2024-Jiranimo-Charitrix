"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSandboxRuntimeAPI = exports.getNodeRuntimeAPI = exports.addMagicAgent = exports.fetchRemote = exports.fetchProduct = void 0;
const tslib_1 = require("tslib");
const node_fetch_1 = tslib_1.__importStar(require("node-fetch"));
const _1 = require(".");
const runtime_1 = require("./runtime");
const polyfill_response_1 = require("./polyfill-response");
const errors_1 = require("./errors");
async function wrapInMetrics(options, cb) {
    const metrics = (0, runtime_1.__getRuntime)().metrics;
    metrics.counter(options.name, options.tags).incr();
    const timer = metrics.timing(options.name, options.tags).measure();
    try {
        return await cb();
    }
    finally {
        timer.stop();
    }
}
function fetchProduct(args) {
    return async (path, init) => {
        const url = productURL(args.remote, path);
        init = (0, exports.addMagicAgent)(init);
        if (!hasAuthorizationHeader(init.headers)) {
            init.headers = { ...init.headers, authorization: `Forge ${args.provider}` };
        }
        const response = await (0, node_fetch_1.default)(url, init);
        handleProxyResponseErrors(response);
        return response;
    };
}
exports.fetchProduct = fetchProduct;
function fetchRemote(args) {
    return async (path, init) => {
        const remoteUrl = new URL(`https://${args.remote}`);
        const url = new URL(path, remoteUrl);
        if (url.hostname !== remoteUrl.hostname) {
            throw new Error(`Invalid path provided ${path}`);
        }
        remoteUrl.searchParams.append('path', path);
        init = (0, exports.addMagicAgent)(init, 'EXTERNAL_AUTH_REQUEST');
        init.headers = {
            ...init.headers,
            authorization: `Forge user ${args.provider} ${args.account}`
        };
        const response = await (0, node_fetch_1.default)(remoteUrl, init);
        handleProxyResponseErrors(response);
        return response;
    };
}
exports.fetchRemote = fetchRemote;
function getDefaultRemote(provider) {
    const externalAuthProvider = findExternalAuthProviderConfigOrThrow(provider);
    if (!externalAuthProvider.remotes.length) {
        throw new Error(`Missing remote config for provider ${provider}`);
    }
    return externalAuthProvider.remotes[0].key;
}
function findExternalAuthProviderConfigOrThrow(provider) {
    const { externalAuth } = (0, runtime_1.__getRuntime)();
    const externalAuthProvider = externalAuth?.find((externalAuthMetaData) => {
        return externalAuthMetaData.service === provider;
    });
    if (!externalAuthProvider) {
        throw new Error(`Bad provider or missing config for provider ${provider}`);
    }
    return externalAuthProvider;
}
const ATLASSIAN_TOKEN_SERVICE_KEY = 'atlassian-token-service-key';
const handleProxyResponseErrors = (response) => {
    if (response.headers.has('forge-proxy-error')) {
        const errorReason = response.headers.get('forge-proxy-error');
        if (errorReason === 'NEEDS_AUTHENTICATION_ERR') {
            throw new errors_1.NeedsAuthenticationError('Authentication Required', ATLASSIAN_TOKEN_SERVICE_KEY);
        }
        throw new errors_1.ProxyRequestError(response.status, response.headers.get('forge-proxy-error'));
    }
};
const hasAuthorizationHeader = (headersInit) => {
    if (!headersInit)
        return false;
    return new node_fetch_1.Headers(headersInit).has('authorization');
};
function productURL(remote, path) {
    if (!path.startsWith('/')) {
        path = '/' + path;
    }
    return `https://${remote}${path}`;
}
function lazyThrowNeedsAuthenticationError(serviceKey) {
    return async (scopes) => wrapInMetrics({ name: 'api.asUser.withProvider.requestCredentials', tags: { passingScopes: String(!!scopes) } }, async () => {
        throw new errors_1.NeedsAuthenticationError('Authentication Required', serviceKey, { scopes, isExpectedError: true });
    });
}
function buildExternalAuthAccountsInfo(provider, remote) {
    const { accounts } = findExternalAuthProviderConfigOrThrow(provider);
    const buildAccountModel = (account) => {
        const { externalAccountId: id, ...rest } = account;
        return { ...rest, id };
    };
    const buildExternalAuthAccountMethods = (account, outboundAuthAccountId) => ({
        hasCredentials: async (scopes) => wrapInMetrics({ name: 'api.asUser.withProvider.hasCredentials', tags: { passingScopes: String(!!scopes) } }, async () => !scopes || scopes.every((scope) => account.scopes.includes(scope))),
        requestCredentials: lazyThrowNeedsAuthenticationError(provider),
        getAccount: async () => wrapInMetrics({ name: 'api.asUser.withProvider.getAccount' }, async () => account),
        fetch: (0, _1.wrapWithRouteUnwrapper)(fetchRemote({ provider, remote: remote ?? getDefaultRemote(provider), account: outboundAuthAccountId }))
    });
    return accounts.map((account) => {
        const authAccount = buildAccountModel(account);
        return {
            account: authAccount,
            methods: buildExternalAuthAccountMethods(authAccount, account.id)
        };
    });
}
const addMagicAgent = (init, agentOverride) => ({
    ...init,
    agent: (agentOverride ?? 'FORGE_PRODUCT_REQUEST')
});
exports.addMagicAgent = addMagicAgent;
const throwNotImplementedError = () => {
    throw new Error('not implemented');
};
const withProvider = (provider, remote) => {
    const accountsInfo = buildExternalAuthAccountsInfo(provider, remote);
    const defaultAccountInfo = accountsInfo.length ? accountsInfo[0] : undefined;
    const lazyThrowNoValidCredentialsError = () => {
        return (url) => {
            throw new Error(`Fetch failed for ${remote ? `remote '${remote}', ` : ''}provider '${provider}', path '${url}' no credentials previously requested`);
        };
    };
    return {
        hasCredentials: async (scopes) => {
            return defaultAccountInfo
                ? await defaultAccountInfo.methods.hasCredentials(scopes)
                : await wrapInMetrics({ name: 'api.asUser.withProvider.hasCredentials', tags: { passingScopes: String(!!scopes) } }, async () => false);
        },
        getAccount: async () => wrapInMetrics({ name: 'api.asUser.withProvider.getAccount' }, async () => {
            return defaultAccountInfo ? defaultAccountInfo.account : undefined;
        }),
        requestCredentials: lazyThrowNeedsAuthenticationError(provider),
        listCredentials: throwNotImplementedError,
        listAccounts: async () => wrapInMetrics({ name: 'api.asUser.withProvider.listAccounts' }, async () => {
            return accountsInfo.map(({ account }) => account);
        }),
        asAccount: (externalAccountId) => {
            const accountInfo = accountsInfo.find(({ account }) => account.id === externalAccountId);
            if (!accountInfo) {
                throw new Error(`No account with ID ${externalAccountId} found for provider ${provider}`);
            }
            return accountInfo.methods;
        },
        fetch: defaultAccountInfo ? defaultAccountInfo.methods.fetch : lazyThrowNoValidCredentialsError()
    };
};
function getNodeRuntimeAPI() {
    return {
        fetch: (0, _1.wrapWithRouteUnwrapper)(node_fetch_1.default),
        requestJira: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'none', remote: 'jira' })),
        requestConfluence: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'none', remote: 'confluence' })),
        requestBitbucket: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'none', remote: 'bitbucket' })),
        asUser: () => ({
            requestJira: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'user', remote: 'jira' })),
            requestConfluence: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'user', remote: 'confluence' })),
            requestBitbucket: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'user', remote: 'bitbucket' })),
            requestGraph: (0, _1.wrapRequestGraph)(fetchProduct({ provider: 'user', remote: 'stargate' })),
            requestConnectedData: (0, _1.wrapRequestConnectedData)(fetchProduct({ provider: 'user', remote: 'stargate' })),
            withProvider
        }),
        asApp: () => ({
            requestJira: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'app', remote: 'jira' })),
            requestConfluence: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'app', remote: 'confluence' })),
            requestBitbucket: (0, _1.wrapRequestProduct)(fetchProduct({ provider: 'app', remote: 'bitbucket' })),
            requestGraph: (0, _1.wrapRequestGraph)(fetchProduct({ provider: 'app', remote: 'stargate' })),
            requestConnectedData: (0, _1.wrapRequestConnectedData)(fetchProduct({ provider: 'app', remote: 'stargate' }))
        })
    };
}
exports.getNodeRuntimeAPI = getNodeRuntimeAPI;
function getSandboxRuntimeAPI(api) {
    return (0, _1.wrapFetchApiMethods)(api, polyfill_response_1.transformResponse);
}
exports.getSandboxRuntimeAPI = getSandboxRuntimeAPI;

import _extends from "@babel/runtime/helpers/extends";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["getStyles", "Icon", "children", "innerProps", "innerRef"];
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/**
 * @jsxRuntime classic
 */
/** @jsx jsx */
// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { css, jsx } from '@emotion/react';
import { Component } from 'react';
import RadioIcon from '@atlaskit/icon/glyph/radio';
import CheckboxIcon from '@atlaskit/icon/glyph/checkbox';
import { B300, B400, B75, N20A, N0, N100, N20, N30, N70 } from '@atlaskit/theme/colors';
var getPrimitiveStyles = function getPrimitiveStyles(props) {
  var cx = props.cx,
    className = props.className,
    getStyles = props.getStyles,
    isDisabled = props.isDisabled,
    isFocused = props.isFocused,
    isSelected = props.isSelected;
  var baseStyles = {
    alignItems: 'center',
    backgroundColor: isFocused ? "var(--ds-background-neutral-subtle-hovered, ".concat(N20, ")") : 'transparent',
    color: isDisabled ? "var(--ds-text-disabled, inherit)" : 'inherit',
    display: 'flex ',
    paddingBottom: "var(--ds-space-050, 4px)",
    paddingLeft: "var(--ds-space-200, 16px)",
    paddingTop: "var(--ds-space-050, 4px)",
    // This 'none' needs to be present to ensure that style is not applied when
    // the option is selected but not focused.
    boxShadow: isFocused ? "inset 2px 0px 0px ".concat("var(--ds-border-focused, ".concat(B400, ")")) : 'none',
    ':active': {
      backgroundColor: "var(--ds-background-neutral-subtle-pressed, ".concat(N30, ")")
    },
    '@media screen and (-ms-high-contrast: active)': {
      borderLeft: isFocused ? '2px solid transparent' : ''
    }
  };
  var augmentedStyles = css(_objectSpread(_objectSpread({}, getStyles('option', props)), baseStyles));
  var bemClasses = {
    option: true,
    'option--is-disabled': isDisabled,
    'option--is-focused': isFocused,
    'option--is-selected': isSelected
  };

  // maintain react-select API
  return [augmentedStyles, cx(bemClasses, className)];
};

// state of the parent option

// the primary color represents the outer or background element
var getPrimaryColor = function getPrimaryColor(_ref) {
  var isActive = _ref.isActive,
    isDisabled = _ref.isDisabled,
    isFocused = _ref.isFocused,
    isSelected = _ref.isSelected;
  if (isDisabled && isSelected) {
    return "var(--ds-background-disabled, ".concat(B75, ")");
  } else if (isDisabled) {
    return "var(--ds-background-disabled, ".concat(N20A, ")");
  } else if (isSelected && isActive) {
    return "var(--ds-background-selected-bold-pressed, ".concat(B75, ")");
  } else if (isActive) {
    return "var(--ds-background-selected-pressed, ".concat(B75, ")");
  } else if (isFocused && isSelected) {
    return "var(--ds-background-selected-bold-hovered, ".concat(B300, ")");
  } else if (isFocused) {
    return "var(--ds-surface, ".concat(N0, ")");
  } else if (isSelected) {
    return "var(--ds-background-selected-bold, ".concat(B400, ")");
  }
  return "var(--ds-background-neutral, ".concat(N0, ")");
};

// the secondary color represents the radio dot or checkmark
var getSecondaryColor = function getSecondaryColor(_ref2) {
  var isActive = _ref2.isActive,
    isDisabled = _ref2.isDisabled,
    isSelected = _ref2.isSelected;
  if (isDisabled && isSelected) {
    return "var(--ds-text-disabled, ".concat(N70, ")");
  } else if (isActive && isSelected && !isDisabled) {
    return "var(--ds-surface, ".concat(B400, ")");
  } else if (!isSelected) {
    return 'transparent';
  }
  return "var(--ds-surface, ".concat(N0, ")");
};

// the border color surrounds the checkbox/radio
var getBorderColor = function getBorderColor(_ref3) {
  var isActive = _ref3.isActive,
    isDisabled = _ref3.isDisabled,
    isFocused = _ref3.isFocused,
    isSelected = _ref3.isSelected;
  if (isDisabled && isSelected) {
    return "var(--ds-background-disabled, ".concat(B400, ")");
  } else if (isDisabled) {
    return "var(--ds-background-disabled, ".concat(N100, ")");
  } else if (isSelected && isActive) {
    return "var(--ds-background-selected-bold-pressed, ".concat(B400, ")");
  } else if (isActive) {
    return "var(--ds-background-selected-bold, ".concat(B400, ")");
  } else if (isFocused && isSelected) {
    return "var(--ds-background-selected-bold-hovered, ".concat(B400, ")");
  } else if (isFocused) {
    return "var(--ds-border-input, ".concat(N100, ")");
  } else if (isSelected) {
    return "var(--ds-background-selected-bold, ".concat(B400, ")");
  }
  return "var(--ds-border-input, ".concat(N100, ")");
};
var baseIconStyles = css({
  alignItems: 'center',
  display: 'flex ',
  flexShrink: 0,
  paddingInlineEnd: "var(--ds-space-050, 4px)",
  // Here we are adding a border to the Checkbox and Radio SVG icons
  // This is an a11y fix for Select only for now but it may be rolled
  // into the `@atlaskit/icon` package's Checkbox and Radio SVGs later
  // eslint-disable-next-line @atlaskit/design-system/no-nested-styles, @atlaskit/ui-styling-standard/no-nested-selectors, @atlaskit/ui-styling-standard/no-unsafe-selectors -- Ignored via go/DSP-18766
  '& svg rect, & svg circle:first-of-type': {
    strokeWidth: "var(--ds-border-width, 1px)",
    strokeLinejoin: 'round'
  }
});
var baseOptionStyles = css({
  textOverflow: 'ellipsis',
  overflowX: 'hidden',
  flexGrow: 1,
  whiteSpace: 'nowrap'
});
var ControlOption = /*#__PURE__*/function (_Component) {
  _inherits(ControlOption, _Component);
  var _super = _createSuper(ControlOption);
  function ControlOption() {
    var _this;
    _classCallCheck(this, ControlOption);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "state", {
      isActive: false
    });
    _defineProperty(_assertThisInitialized(_this), "onMouseDown", function () {
      return _this.setState({
        isActive: true
      });
    });
    _defineProperty(_assertThisInitialized(_this), "onMouseUp", function () {
      return _this.setState({
        isActive: false
      });
    });
    _defineProperty(_assertThisInitialized(_this), "onMouseLeave", function () {
      return _this.setState({
        isActive: false
      });
    });
    return _this;
  }
  _createClass(ControlOption, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        getStyles = _this$props.getStyles,
        Icon = _this$props.Icon,
        children = _this$props.children,
        innerProps = _this$props.innerProps,
        innerRef = _this$props.innerRef,
        rest = _objectWithoutProperties(_this$props, _excluded);

      // prop assignment
      var props = _objectSpread(_objectSpread({}, innerProps), {}, {
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp,
        onMouseLeave: this.onMouseLeave
      });
      var _getPrimitiveStyles = getPrimitiveStyles(_objectSpread({
          getStyles: getStyles
        }, rest)),
        _getPrimitiveStyles2 = _slicedToArray(_getPrimitiveStyles, 2),
        styles = _getPrimitiveStyles2[0],
        classes = _getPrimitiveStyles2[1];
      return (
        // These need to remain this way because `react-select` passes props with
        // styles inside, and that must be done dynamically.
        // eslint-disable-next-line @atlaskit/design-system/consistent-css-prop-usage, @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
        jsx("div", _extends({
          css: styles,
          className: classes,
          ref: innerRef
        }, props), jsx("div", {
          css: [baseIconStyles,
          // Here we are adding a border to the Checkbox and Radio SVG icons
          // This is an a11y fix for Select only for now but it may be rolled
          // into the `@atlaskit/icon` package's Checkbox and Radio SVGs later
          // eslint-disable-next-line @atlaskit/design-system/consistent-css-prop-usage
          {
            // This can eventually be changed to static styles that are
            // applied conditionally (e.g. `isActive && activeBorderStyles`),
            // but considering there are multiple instances of `react-select`
            // requiring styles to be generated dynamically, it seemed like a
            // low priority.
            // eslint-disable-next-line @atlaskit/design-system/no-nested-styles
            '& svg rect, & svg circle:first-of-type': {
              stroke: getBorderColor(_objectSpread(_objectSpread({}, this.props), this.state))
            }
          }]
        }, !!Icon ? jsx(Icon, {
          label: "",
          primaryColor: getPrimaryColor(_objectSpread(_objectSpread({}, this.props), this.state)),
          secondaryColor: getSecondaryColor(_objectSpread(_objectSpread({}, this.props), this.state))
        }) : null), jsx("div", {
          css: baseOptionStyles
        }, children))
      );
    }
  }]);
  return ControlOption;
}(Component);
export var CheckboxOption = function CheckboxOption(props) {
  return jsx(ControlOption, _extends({
    Icon: CheckboxIcon
  }, props));
};
export var RadioOption = function RadioOption(props) {
  return jsx(ControlOption, _extends({
    Icon: RadioIcon
  }, props));
};
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _extends from "@babel/runtime/helpers/extends";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["isRankable", "isRanking", "onRankStart", "onRankEnd", "isRankingDisabled"];
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
import React, { forwardRef, lazy, Suspense, useEffect, useState } from 'react';
import { createAndFireEvent, withAnalyticsContext, withAnalyticsEvents } from '@atlaskit/analytics-next';
import noop from '@atlaskit/ds-lib/noop';
import { ASC, DESC, LARGE, SMALL } from '../internal/constants';
import { assertIsSortable, getPageRows, validateSortKey } from '../internal/helpers';
import { Caption, PaginationWrapper, Table } from '../styled/dynamic-table';
import { EmptyViewContainer, EmptyViewWithFixedHeight } from '../styled/empty-body';
import Body from './body';
import { ErrorBoundary } from './error-boundary';
import LoadingContainer from './loading-container';
import LoadingContainerAdvanced from './loading-container-advanced';
import ManagedPagination from './managed-pagination';
import TableHead from './table-head';
var packageName = "@atlaskit/dynamic-table";
var packageVersion = "14.18.1";
function toggleSortOrder(currentSortOrder) {
  switch (currentSortOrder) {
    case DESC:
      return ASC;
    case ASC:
      return DESC;
    default:
      return currentSortOrder;
  }
}
var DynamicTable = /*#__PURE__*/function (_React$Component) {
  _inherits(DynamicTable, _React$Component);
  var _super = _createSuper(DynamicTable);
  function DynamicTable() {
    var _this;
    _classCallCheck(this, DynamicTable);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "tableBody", /*#__PURE__*/React.createRef());
    _defineProperty(_assertThisInitialized(_this), "state", {
      isRanking: false
    });
    _defineProperty(_assertThisInitialized(_this), "onSortHandler", function (item) {
      return function () {
        var _this$props = _this.props,
          sortKey = _this$props.sortKey,
          sortOrder = _this$props.sortOrder,
          onSort = _this$props.onSort,
          isRankable = _this$props.isRankable;
        var key = item.key;
        if (!key) {
          return;
        }
        if (onSort && isRankable && key === sortKey && sortOrder === DESC) {
          onSort({
            key: null,
            sortOrder: null,
            item: item
          });
          return;
        }
        var sortOrderFormatted = key !== sortKey ? ASC : toggleSortOrder(sortOrder);
        if (onSort) {
          onSort({
            key: key,
            item: item,
            sortOrder: sortOrderFormatted
          });
        }
      };
    });
    _defineProperty(_assertThisInitialized(_this), "onSetPageHandler", function (page, event) {
      var onSetPage = _this.props.onSetPage;
      if (onSetPage) {
        onSetPage(page, event);
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onRankStartHandler", function (params) {
      _this.setState({
        isRanking: true
      });
      if (_this.props.onRankStart) {
        _this.props.onRankStart(params);
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onRankEndHandler", function (params) {
      _this.setState({
        isRanking: false
      });
      if (_this.props.onRankEnd) {
        _this.props.onRankEnd(params);
      }
    });
    _defineProperty(_assertThisInitialized(_this), "getSpinnerSize", function () {
      var _this$props2 = _this.props,
        page = _this$props2.page,
        rows = _this$props2.rows,
        rowsPerPage = _this$props2.rowsPerPage,
        loadingSpinnerSize = _this$props2.loadingSpinnerSize;
      if (loadingSpinnerSize) {
        return loadingSpinnerSize;
      }
      return getPageRows(rows || [], page, rowsPerPage).length > 2 ? LARGE : SMALL;
    });
    _defineProperty(_assertThisInitialized(_this), "renderEmptyBody", function () {
      var _this$props3 = _this.props,
        emptyView = _this$props3.emptyView,
        isLoading = _this$props3.isLoading,
        testId = _this$props3.testId;
      if (isLoading) {
        return /*#__PURE__*/React.createElement(EmptyViewWithFixedHeight, {
          testId: testId
        });
      }
      return emptyView && /*#__PURE__*/React.createElement(EmptyViewContainer, {
        testId: testId
      }, emptyView);
    });
    return _this;
  }
  _createClass(DynamicTable, [{
    key: "UNSAFE_componentWillMount",
    value: function UNSAFE_componentWillMount() {
      validateSortKey(this.props.sortKey, this.props.head);
      assertIsSortable(this.props.head);
    }
  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      if (this.props.sortKey !== nextProps.sortKey || this.props.head !== nextProps.head) {
        validateSortKey(nextProps.sortKey, nextProps.head);
      }
      if (this.props.head !== nextProps.head) {
        assertIsSortable(nextProps.head);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props4 = this.props,
        caption = _this$props4.caption,
        head = _this$props4.head,
        highlightedRowIndex = _this$props4.highlightedRowIndex,
        isFixedSize = _this$props4.isFixedSize,
        page = _this$props4.page,
        rows = _this$props4.rows,
        rowsPerPage = _this$props4.rowsPerPage,
        sortKey = _this$props4.sortKey,
        sortOrder = _this$props4.sortOrder,
        isLoading = _this$props4.isLoading,
        loadingLabel = _this$props4.loadingLabel,
        isRankable = _this$props4.isRankable,
        isRankingDisabled = _this$props4.isRankingDisabled,
        paginationi18n = _this$props4.paginationi18n,
        onPageRowsUpdate = _this$props4.onPageRowsUpdate,
        testId = _this$props4.testId,
        passedDownTotalRows = _this$props4.totalRows,
        label = _this$props4.label;
      var rowsLength = rows && rows.length;
      var totalPages;
      // set a flag to denote the dynamic table might get only one page of data
      // for paginated data
      var isTotalPagesControlledExternally = false;
      if (passedDownTotalRows && Number.isInteger(passedDownTotalRows) && rowsPerPage && rowsLength && rowsLength <= passedDownTotalRows) {
        /**
         * If total number of rows / records have been passed down as prop
         * Then table is being fed paginated data from server or other sources
         * In this case, we want to respect information passed down by server or external source
         * Rather than relying on our computation based on number of rows
         */
        totalPages = Math.ceil(passedDownTotalRows / rowsPerPage);
        isTotalPagesControlledExternally = true;
      } else {
        totalPages = rowsLength && rowsPerPage ? Math.ceil(rowsLength / rowsPerPage) : 0;
      }
      totalPages = totalPages < 1 ? 1 : totalPages;
      var getPageNumber = page > totalPages ? totalPages : page; // page! required, because typescript can't yet see defaultProps to know that this won't be undefined

      var bodyProps = {
        highlightedRowIndex: highlightedRowIndex,
        rows: rows,
        head: head,
        sortKey: sortKey,
        sortOrder: sortOrder,
        rowsPerPage: rowsPerPage,
        page: getPageNumber,
        isFixedSize: isFixedSize || false,
        onPageRowsUpdate: onPageRowsUpdate,
        isTotalPagesControlledExternally: isTotalPagesControlledExternally,
        ref: this.tableBody,
        testId: testId
      };
      var rowsExist = !!rowsLength;
      var spinnerSize = this.getSpinnerSize();
      var emptyBody = this.renderEmptyBody();
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(LoadingContainerAdvanced, {
        isLoading: isLoading && rowsExist,
        spinnerSize: spinnerSize,
        targetRef: function targetRef() {
          return _this2.tableBody.current;
        },
        testId: testId,
        loadingLabel: loadingLabel
      }, /*#__PURE__*/React.createElement(Table, {
        isFixedSize: isFixedSize,
        "aria-label": label,
        hasDataRow: rowsExist,
        testId: testId,
        isLoading: isLoading
      }, !!caption && /*#__PURE__*/React.createElement(Caption, null, caption), head && /*#__PURE__*/React.createElement(TableHead, {
        head: head,
        onSort: this.onSortHandler,
        sortKey: sortKey,
        sortOrder: sortOrder,
        isRanking: this.state.isRanking,
        isRankable: isRankable,
        testId: testId
      }), rowsExist && /*#__PURE__*/React.createElement(TableBody, _extends({}, bodyProps, {
        isRankable: this.props.isRankable,
        isRanking: this.state.isRanking,
        onRankStart: this.onRankStartHandler,
        onRankEnd: this.onRankEndHandler,
        isRankingDisabled: isRankingDisabled || isLoading || false
      })))), totalPages <= 1 ? null :
      /*#__PURE__*/
      // only show pagination if there's MORE than 1 page
      React.createElement(PaginationWrapper, {
        testId: testId
      }, /*#__PURE__*/React.createElement(ManagedPagination, {
        value: getPageNumber,
        onChange: this.onSetPageHandler,
        total: totalPages,
        i18n: paginationi18n,
        isDisabled: isLoading,
        testId: testId
      })), !rowsExist && emptyBody && /*#__PURE__*/React.createElement(LoadingContainer, {
        isLoading: isLoading,
        spinnerSize: LARGE,
        testId: testId,
        loadingLabel: loadingLabel
      }, emptyBody));
    }
  }]);
  return DynamicTable;
}(React.Component);
_defineProperty(DynamicTable, "defaultProps", {
  isLoading: false,
  isFixedSize: false,
  rowsPerPage: Infinity,
  onSetPage: noop,
  onSort: noop,
  page: 1,
  isRankable: false,
  isRankingDisabled: false,
  onRankStart: noop,
  onRankEnd: noop,
  paginationi18n: {
    prev: 'Previous',
    next: 'Next',
    label: 'Pagination',
    pageLabel: 'Page'
  }
});
var RankableTableBody = /*#__PURE__*/lazy(function () {
  return import( /* webpackChunkName: '@atlaskit-internal_dynamic-table' */'./rankable/body');
});
var TableBody = /*#__PURE__*/forwardRef(function TableBody(_ref, ref) {
  var _ref$isRankable = _ref.isRankable,
    isRankable = _ref$isRankable === void 0 ? false : _ref$isRankable,
    isRanking = _ref.isRanking,
    onRankStart = _ref.onRankStart,
    onRankEnd = _ref.onRankEnd,
    isRankingDisabled = _ref.isRankingDisabled,
    bodyProps = _objectWithoutProperties(_ref, _excluded);
  var canRank = isRankable && !bodyProps.sortKey;

  /**
   * React 16 does not support SSR for lazy components,
   * so we avoid rendering the `Suspense` on the server.
   */
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    canRenderRankable = _useState2[0],
    setCanRenderRankable = _useState2[1];
  useEffect(function () {
    if (canRank) {
      setCanRenderRankable(true);
    }
  }, [canRank]);
  var nonRankableBody = /*#__PURE__*/React.createElement(Body, _extends({
    ref: ref
  }, bodyProps));
  return canRank && canRenderRankable ? /*#__PURE__*/React.createElement(ErrorBoundary, {
    fallback: nonRankableBody
  }, /*#__PURE__*/React.createElement(Suspense, {
    fallback: nonRankableBody
  }, /*#__PURE__*/React.createElement(RankableTableBody, _extends({
    ref: ref
  }, bodyProps, {
    isRanking: isRanking,
    onRankStart: onRankStart,
    onRankEnd: onRankEnd,
    isRankingDisabled: isRankingDisabled
  })))) : nonRankableBody;
});
export { DynamicTable as DynamicTableWithoutAnalytics };
var createAndFireEventOnAtlaskit = createAndFireEvent('atlaskit');
export default withAnalyticsContext({
  componentName: 'dynamicTable',
  packageName: packageName,
  packageVersion: packageVersion
})(withAnalyticsEvents({
  onSort: createAndFireEventOnAtlaskit({
    action: 'sorted',
    actionSubject: 'dynamicTable',
    attributes: {
      componentName: 'dynamicTable',
      packageName: packageName,
      packageVersion: packageVersion
    }
  }),
  onRankEnd: createAndFireEventOnAtlaskit({
    action: 'ranked',
    actionSubject: 'dynamicTable',
    attributes: {
      componentName: 'dynamicTable',
      packageName: packageName,
      packageVersion: packageVersion
    }
  })
})(DynamicTable));
import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React, { forwardRef, lazy, Suspense, useEffect, useState } from 'react';
import { createAndFireEvent, withAnalyticsContext, withAnalyticsEvents } from '@atlaskit/analytics-next';
import noop from '@atlaskit/ds-lib/noop';
import { ASC, DESC, LARGE, SMALL } from '../internal/constants';
import { assertIsSortable, getPageRows, validateSortKey } from '../internal/helpers';
import { Caption, PaginationWrapper, Table } from '../styled/dynamic-table';
import { EmptyViewContainer, EmptyViewWithFixedHeight } from '../styled/empty-body';
import Body from './body';
import { ErrorBoundary } from './error-boundary';
import LoadingContainer from './loading-container';
import LoadingContainerAdvanced from './loading-container-advanced';
import ManagedPagination from './managed-pagination';
import TableHead from './table-head';
const packageName = "@atlaskit/dynamic-table";
const packageVersion = "14.18.1";
function toggleSortOrder(currentSortOrder) {
  switch (currentSortOrder) {
    case DESC:
      return ASC;
    case ASC:
      return DESC;
    default:
      return currentSortOrder;
  }
}
class DynamicTable extends React.Component {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "tableBody", /*#__PURE__*/React.createRef());
    _defineProperty(this, "state", {
      isRanking: false
    });
    _defineProperty(this, "onSortHandler", item => () => {
      const {
        sortKey,
        sortOrder,
        onSort,
        isRankable
      } = this.props;
      const {
        key
      } = item;
      if (!key) {
        return;
      }
      if (onSort && isRankable && key === sortKey && sortOrder === DESC) {
        onSort({
          key: null,
          sortOrder: null,
          item
        });
        return;
      }
      const sortOrderFormatted = key !== sortKey ? ASC : toggleSortOrder(sortOrder);
      if (onSort) {
        onSort({
          key,
          item,
          sortOrder: sortOrderFormatted
        });
      }
    });
    _defineProperty(this, "onSetPageHandler", (page, event) => {
      const {
        onSetPage
      } = this.props;
      if (onSetPage) {
        onSetPage(page, event);
      }
    });
    _defineProperty(this, "onRankStartHandler", params => {
      this.setState({
        isRanking: true
      });
      if (this.props.onRankStart) {
        this.props.onRankStart(params);
      }
    });
    _defineProperty(this, "onRankEndHandler", params => {
      this.setState({
        isRanking: false
      });
      if (this.props.onRankEnd) {
        this.props.onRankEnd(params);
      }
    });
    _defineProperty(this, "getSpinnerSize", () => {
      const {
        page,
        rows,
        rowsPerPage,
        loadingSpinnerSize
      } = this.props;
      if (loadingSpinnerSize) {
        return loadingSpinnerSize;
      }
      return getPageRows(rows || [], page, rowsPerPage).length > 2 ? LARGE : SMALL;
    });
    _defineProperty(this, "renderEmptyBody", () => {
      const {
        emptyView,
        isLoading,
        testId
      } = this.props;
      if (isLoading) {
        return /*#__PURE__*/React.createElement(EmptyViewWithFixedHeight, {
          testId: testId
        });
      }
      return emptyView && /*#__PURE__*/React.createElement(EmptyViewContainer, {
        testId: testId
      }, emptyView);
    });
  }
  UNSAFE_componentWillMount() {
    validateSortKey(this.props.sortKey, this.props.head);
    assertIsSortable(this.props.head);
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    if (this.props.sortKey !== nextProps.sortKey || this.props.head !== nextProps.head) {
      validateSortKey(nextProps.sortKey, nextProps.head);
    }
    if (this.props.head !== nextProps.head) {
      assertIsSortable(nextProps.head);
    }
  }
  render() {
    const {
      caption,
      head,
      highlightedRowIndex,
      isFixedSize,
      page,
      rows,
      rowsPerPage,
      sortKey,
      sortOrder,
      isLoading,
      loadingLabel,
      isRankable,
      isRankingDisabled,
      paginationi18n,
      onPageRowsUpdate,
      testId,
      totalRows: passedDownTotalRows,
      label
    } = this.props;
    const rowsLength = rows && rows.length;
    let totalPages;
    // set a flag to denote the dynamic table might get only one page of data
    // for paginated data
    let isTotalPagesControlledExternally = false;
    if (passedDownTotalRows && Number.isInteger(passedDownTotalRows) && rowsPerPage && rowsLength && rowsLength <= passedDownTotalRows) {
      /**
       * If total number of rows / records have been passed down as prop
       * Then table is being fed paginated data from server or other sources
       * In this case, we want to respect information passed down by server or external source
       * Rather than relying on our computation based on number of rows
       */
      totalPages = Math.ceil(passedDownTotalRows / rowsPerPage);
      isTotalPagesControlledExternally = true;
    } else {
      totalPages = rowsLength && rowsPerPage ? Math.ceil(rowsLength / rowsPerPage) : 0;
    }
    totalPages = totalPages < 1 ? 1 : totalPages;
    const getPageNumber = page > totalPages ? totalPages : page; // page! required, because typescript can't yet see defaultProps to know that this won't be undefined

    const bodyProps = {
      highlightedRowIndex,
      rows,
      head,
      sortKey,
      sortOrder,
      rowsPerPage,
      page: getPageNumber,
      isFixedSize: isFixedSize || false,
      onPageRowsUpdate,
      isTotalPagesControlledExternally,
      ref: this.tableBody,
      testId
    };
    const rowsExist = !!rowsLength;
    const spinnerSize = this.getSpinnerSize();
    const emptyBody = this.renderEmptyBody();
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(LoadingContainerAdvanced, {
      isLoading: isLoading && rowsExist,
      spinnerSize: spinnerSize,
      targetRef: () => this.tableBody.current,
      testId: testId,
      loadingLabel: loadingLabel
    }, /*#__PURE__*/React.createElement(Table, {
      isFixedSize: isFixedSize,
      "aria-label": label,
      hasDataRow: rowsExist,
      testId: testId,
      isLoading: isLoading
    }, !!caption && /*#__PURE__*/React.createElement(Caption, null, caption), head && /*#__PURE__*/React.createElement(TableHead, {
      head: head,
      onSort: this.onSortHandler,
      sortKey: sortKey,
      sortOrder: sortOrder,
      isRanking: this.state.isRanking,
      isRankable: isRankable,
      testId: testId
    }), rowsExist && /*#__PURE__*/React.createElement(TableBody, _extends({}, bodyProps, {
      isRankable: this.props.isRankable,
      isRanking: this.state.isRanking,
      onRankStart: this.onRankStartHandler,
      onRankEnd: this.onRankEndHandler,
      isRankingDisabled: isRankingDisabled || isLoading || false
    })))), totalPages <= 1 ? null :
    /*#__PURE__*/
    // only show pagination if there's MORE than 1 page
    React.createElement(PaginationWrapper, {
      testId: testId
    }, /*#__PURE__*/React.createElement(ManagedPagination, {
      value: getPageNumber,
      onChange: this.onSetPageHandler,
      total: totalPages,
      i18n: paginationi18n,
      isDisabled: isLoading,
      testId: testId
    })), !rowsExist && emptyBody && /*#__PURE__*/React.createElement(LoadingContainer, {
      isLoading: isLoading,
      spinnerSize: LARGE,
      testId: testId,
      loadingLabel: loadingLabel
    }, emptyBody));
  }
}
_defineProperty(DynamicTable, "defaultProps", {
  isLoading: false,
  isFixedSize: false,
  rowsPerPage: Infinity,
  onSetPage: noop,
  onSort: noop,
  page: 1,
  isRankable: false,
  isRankingDisabled: false,
  onRankStart: noop,
  onRankEnd: noop,
  paginationi18n: {
    prev: 'Previous',
    next: 'Next',
    label: 'Pagination',
    pageLabel: 'Page'
  }
});
const RankableTableBody = /*#__PURE__*/lazy(() => import( /* webpackChunkName: '@atlaskit-internal_dynamic-table' */'./rankable/body'));
const TableBody = /*#__PURE__*/forwardRef(function TableBody({
  isRankable = false,
  isRanking,
  onRankStart,
  onRankEnd,
  isRankingDisabled,
  ...bodyProps
}, ref) {
  const canRank = isRankable && !bodyProps.sortKey;

  /**
   * React 16 does not support SSR for lazy components,
   * so we avoid rendering the `Suspense` on the server.
   */
  const [canRenderRankable, setCanRenderRankable] = useState(false);
  useEffect(() => {
    if (canRank) {
      setCanRenderRankable(true);
    }
  }, [canRank]);
  const nonRankableBody = /*#__PURE__*/React.createElement(Body, _extends({
    ref: ref
  }, bodyProps));
  return canRank && canRenderRankable ? /*#__PURE__*/React.createElement(ErrorBoundary, {
    fallback: nonRankableBody
  }, /*#__PURE__*/React.createElement(Suspense, {
    fallback: nonRankableBody
  }, /*#__PURE__*/React.createElement(RankableTableBody, _extends({
    ref: ref
  }, bodyProps, {
    isRanking: isRanking,
    onRankStart: onRankStart,
    onRankEnd: onRankEnd,
    isRankingDisabled: isRankingDisabled
  })))) : nonRankableBody;
});
export { DynamicTable as DynamicTableWithoutAnalytics };
const createAndFireEventOnAtlaskit = createAndFireEvent('atlaskit');
export default withAnalyticsContext({
  componentName: 'dynamicTable',
  packageName,
  packageVersion
})(withAnalyticsEvents({
  onSort: createAndFireEventOnAtlaskit({
    action: 'sorted',
    actionSubject: 'dynamicTable',
    attributes: {
      componentName: 'dynamicTable',
      packageName,
      packageVersion
    }
  }),
  onRankEnd: createAndFireEventOnAtlaskit({
    action: 'ranked',
    actionSubject: 'dynamicTable',
    attributes: {
      componentName: 'dynamicTable',
      packageName,
      packageVersion
    }
  })
})(DynamicTable));
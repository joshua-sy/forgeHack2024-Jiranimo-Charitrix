import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import getInlineLineNumber from './get-inline-line-number';
export default function createLineElement(_ref) {
  var children = _ref.children,
    lineNumber = _ref.lineNumber,
    showLineNumbers = _ref.showLineNumbers,
    _ref$lineProps = _ref.lineProps,
    lineProps = _ref$lineProps === void 0 ? {} : _ref$lineProps,
    _ref$className = _ref.className,
    className = _ref$className === void 0 ? [] : _ref$className;
  var propsPassedInFromCodeBlock = typeof lineProps === 'function' ? lineProps(lineNumber) : lineProps;
  var properties = _objectSpread(_objectSpread({}, propsPassedInFromCodeBlock), {}, {
    className: className
  });
  var currentChildren = children;
  if (lineNumber && showLineNumbers) {
    // When syntax highlighting is NOT turned on, the entire LOC is just a single
    // child. We can then happily create the line number and the LOC as siblings...
    if (currentChildren.length === 1) {
      currentChildren = [getInlineLineNumber(lineNumber)].concat(_toConsumableArray(currentChildren));
    } else {
      // ... However, when syntax highlighting IS on, a span is created for each
      // tokenised node in the AST (eg. <span>import</span><span>React</span>).
      // When shouldWrapLongLines is true, the row becomes `display: flex` and
      // forces all its children to be equal height. This can be a source of
      // visual bugs where a LOC is broken up weirdly into segments.
      //
      //  +---------------------------------------+
      //  | row                                   |
      //  |  +----+ +-------+ +--------+ +------+ |
      //  |  |line| |key    | |keywords| |key   | |
      //  |  |no. | |word   | |        | |word  | |
      //  |  |    | |       | |        | |      | |
      //  |  +----+ +-------+ +--------+ +------+ |
      //  +---------------------------------------+
      //
      // Nesting the children one layer deeper (i.e. creating an extra span)
      // ensures that the line number and the ENTIRE line of code are aligned by
      // the parent flexbox (the row).
      //
      //  +---------------------------------------------+
      //  | row                                         |
      //  | +----+  +--------------------------------+  |
      //  | |line|  | extra span we are creating     |  |
      //  | |no. |  |  +-------+ +--------+ +------+ |  |
      //  | |    |  |  |key    | |keywords| |key   | |  |
      //  | |    |  |  |word   | |        | |word  | |  |
      //  | |    |  |  |       | |        | |      | |  |
      //  | |    |  |  +-------+ +--------+ +------+ |  |
      //  | +----+  +--------------------------------+  |
      //  +---------------------------------------------+
      //
      currentChildren = [getInlineLineNumber(lineNumber), {
        type: 'element',
        tagName: 'span',
        properties: {
          className: []
        },
        children: currentChildren
      }];
    }
  }
  return {
    type: 'element',
    tagName: 'span',
    properties: properties,
    children: currentChildren
  };
}